# Writeup for picoCTF 2019 : dont-use-client-side

## Tools:
- Web browser with developer tools
- JavaScript source code analysis
- Client-side code inspection
- String reconstruction techniques

## Steps:

### 1. Initial Challenge Analysis
This challenge presented me with a web application that appeared to have some form of password verification system. The challenge title "dont-use-client-side" immediately provided a strong hint about the vulnerability - it suggested that the application was performing security validation on the client side rather than the server side.

The title effectively warned against the security practice that the challenge was designed to demonstrate, indicating that I should examine the client-side code to find the validation logic.

### 2. Understanding Client-Side Security Vulnerabilities
The challenge title highlighted a fundamental web security principle: client-side validation should never be trusted as the sole security mechanism. This is because:

- Client-side code is accessible to users and can be easily examined
- JavaScript validation can be bypassed or modified by users
- Any security logic visible to the client can be reverse-engineered
- Proper security validation should always occur on the server side

### 3. Examining the Client-Side JavaScript
I opened the web application and used the browser's developer tools to examine the client-side JavaScript code. This analysis revealed the presence of a `verify` function that contained the password validation logic.

The discovery of client-side validation logic confirmed that the application was vulnerable to the security flaw suggested by the challenge title.

### 4. Analyzing the Verify Function Structure
Upon examining the `verify` function, I found a complex nested structure of conditional statements that validated different portions of the password. The function structure revealed:

- A variable called `split` set to the value 4, used as a segment size
- Multiple nested `if` statements checking different segments of the password
- Each condition compared a specific substring of the input against a hardcoded value
- The validation logic was completely exposed in the client-side code

### 5. Deconstructing the Password Validation Logic
The JavaScript code showed the complete validation function:

```javascript
  function verify() {
    checkpass = document.getElementById("pass").value;
    split = 4;
    if (checkpass.substring(0, split) == 'pico') {
      if (checkpass.substring(split*6, split*7) == '706c') {
        if (checkpass.substring(split, split*2) == 'CTF{') {
         if (checkpass.substring(split*4, split*5) == 'ts_p') {
          if (checkpass.substring(split*3, split*4) == 'lien') {
            if (checkpass.substring(split*5, split*6) == 'lz_b') {
              if (checkpass.substring(split*2, split*3) == 'no_c') {
                if (checkpass.substring(split*7, split*8) == '5}') {
                  alert("Password Verified")
                  }
                }
              }
      
            }
          }
        }
      }
    }
    else {
      alert("Incorrect password");
    }
    
  }
```

The function worked by:
- Taking the user's password input from a form field
- Dividing it into segments of 4 characters each (using the `split` variable)
- Checking each segment against predetermined values using substring operations
- Only succeeding if all segments matched their expected values in the correct positions

### 6. Reconstructing the Password from Validation Logic
By carefully analyzing each conditional statement, I could extract the expected values for each segment of the password:

- Position 0 to 4: `'pico'`
- Position 4 to 8: `'CTF{'`
- Position 8 to 12: `'no_c'`
- Position 12 to 16: `'lien'`
- Position 16 to 20: `'ts_p'`
- Position 20 to 24: `'lz_b'`
- Position 24 to 28: `'706c'`
- Position 28 to 32: `'5}'`

### 7. Assembling the Complete Flag
By concatenating all the segments in their correct order, I reconstructed the complete password that the validation function was expecting:

`pico` + `CTF{` + `no_c` + `lien` + `ts_p` + `lz_b` + `706c` + `5}` = `picoCTF{no_clients_plz_b706c5}`

### 8. Verification and Solution
I verified the reconstructed password by either entering it into the application's password field or by understanding that the concatenated segments formed a valid picoCTF flag format. The successful reconstruction demonstrated how client-side validation can be easily circumvented through code analysis.

### 9. Learning Outcomes
This challenge effectively demonstrated several important web security concepts:

- **Client-side validation vulnerabilities**: How validation logic exposed to clients can be easily bypassed
- **Security through obscurity failures**: Why hiding security logic in client-side code is ineffective
- **Code analysis techniques**: Methods for reverse-engineering client-side validation logic
- **Proper security practices**: The importance of server-side validation for actual security

The challenge highlighted why client-side validation should only be used for user experience enhancement, never as a security control.

## Flag:
```picoCTF{no_clients_plz_b706c5}```
